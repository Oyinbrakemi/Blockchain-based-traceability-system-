<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agricultural Traceability System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .user-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border-radius: 10px;
            font-weight: 600;
            position: relative;
        }

        .logout-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: white;
            color: #3498db;
            transform: translateY(-50%) scale(1.05);
        }

        .wallet-section {
            background: linear-gradient(135deg, #e8f5e8, #f0f8f0);
            border: 2px solid #27ae60;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .wallet-section h3 {
            color: #27ae60;
            margin-bottom: 15px;
        }

        .wallet-info {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }

        .connect-wallet-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin: 10px 5px;
        }

        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .disconnect-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .tab {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .tab.active {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            transform: scale(1.05);
        }

        .tab.disabled {
            background: #95a5a6;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }

        .tab.disabled:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin: 10px 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 600;
            text-align: center;
        }

        .status.success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .status.error {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .status.info {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .status.warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }

        .product-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .product-card:hover {
            transform: translateY(-5px);
        }

        .product-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .product-id {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .status-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .status-harvested { background: #f39c12; color: white; }
        .status-processing { background: #e67e22; color: white; }
        .status-packaged { background: #3498db; color: white; }
        .status-shipped { background: #9b59b6; color: white; }
        .status-delivered { background: #27ae60; color: white; }
        .status-recalled { background: #e74c3c; color: white; }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .connected {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .disconnected {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .track-section {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .track-form {
            display: flex;
            gap: 15px;
            align-items: end;
            flex-wrap: wrap;
        }

        .track-form .form-group {
            margin-bottom: 0;
            flex: 1;
            min-width: 200px;
        }

        .track-form button {
            margin: 0;
            white-space: nowrap;
        }

        .role-registration {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

        .role-registration h2 {
            color: #d68910;
            margin-bottom: 15px;
        }

        .role-registration p {
            color: #b7950b;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .access-denied {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            border: 2px solid #e74c3c;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
            color: #721c24;
        }

        .debug-corner {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
        }

        .debug-corner button {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            margin: 2px;
        }

        .wallet-controls {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .wallet-controls button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            margin: 0;
        }

        .wallet-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .wallet-controls .disconnect-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .wallet-controls .switch-btn {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 20px;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                margin: 2px 0;
            }
            
            h1 {
                font-size: 2em;
            }

            .track-form {
                flex-direction: column;
            }

            .track-form .form-group {
                min-width: 100%;
            }

            .wallet-controls {
                position: relative;
                top: auto;
                right: auto;
                margin: 20px 0;
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
            }

            .logout-btn {
                position: relative;
                right: auto;
                top: auto;
                transform: none;
                margin: 10px auto;
                display: block;
            }

            .user-info {
                text-align: left;
                padding: 20px 15px;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        üî¥ Initializing...
    </div>

    <div class="wallet-controls">
        <button onclick="connectWallet()" id="connectBtn">üîó Connect</button>
        <button onclick="switchAccount()" id="switchBtn" class="switch-btn" title="Switch Account">üîÑ Switch</button>
        <button onclick="disconnectWallet()" id="disconnectBtn" class="disconnect-btn" title="Disconnect Wallet">üö™ Logout</button>
    </div>

    <div class="debug-corner">
        <button onclick="forceReconnect()" title="Force Reconnect">üîÑ</button>
        <button onclick="showDebugInfo()" title="Debug Info">üìä</button>
    </div>

    <div class="container">
        <h1>üåæ Agricultural Traceability System</h1>
        
        <!-- Wallet Connection Section -->
        <div id="walletSection" class="wallet-section" style="display: none;">
            <h3>üëõ Wallet Connection</h3>
            <p>Connect your MetaMask wallet to access the Agricultural Traceability System</p>
            <button onclick="connectWallet()" class="connect-wallet-btn">Connect MetaMask</button>
        </div>
        
        <div id="userInfo" class="user-info" style="display: none;">
            <button onclick="logoutUser()" class="logout-btn">Logout</button>
        </div>
        
        <div class="tabs" id="tabsContainer">
            <button class="tab active" onclick="showTab('register')">Register Product</button>
            <button class="tab" onclick="showTab('track')">Track Product</button>
            <button class="tab" onclick="showTab('transport')">Transport</button>
            <button class="tab" onclick="showTab('quality')">Quality Test</button>
            <button class="tab" onclick="showTab('batch')">Create Batch</button>
            <button class="tab" onclick="showTab('stakeholder')">Stakeholders</button>
        </div>

        <!-- Role Registration Prompt -->
        <div id="rolePrompt" class="role-registration" style="display: none;">
            <h2>üîê Access Control Enabled</h2>
            <p>Please register as a stakeholder to access role-specific features. The tracking feature remains available to everyone.</p>
            <button onclick="showTab('stakeholder')" class="tab">Register as Stakeholder</button>
        </div>

        <!-- Register Product Tab -->
        <div id="register" class="tab-content active">
            <div id="registerAccess">
                <h2>Register New Product</h2>
                <form id="registerForm">
                    <div class="grid">
    <div class="form-group">
        <label for="productName">Product Name:</label>
        <input type="text" id="productName" required>
    </div>
    <div class="form-group">
        <label for="variety">Variety:</label>
        <input type="text" id="variety" required>
    </div>
    <div class="form-group">
        <label for="origin">Origin:</label>
        <input type="text" id="origin" required>
    </div>
    <div class="form-group">
        <label for="plantedDate">Planted Date:</label>
        <input type="date" id="plantedDate" required>
    </div>
    <div class="form-group">
        <label for="harvestedDate">Harvested Date:</label>
        <input type="date" id="harvestedDate" required>
    </div> 
    <div class="form-group">
        <label for="isOrganic">Organic:</label>
        <select id="isOrganic">
            <option value="false">No</option>
            <option value="true">Yes</option>
        </select>
    </div>
</div>
                    <div class="form-group">
                        <label for="certifications">Certifications (comma-separated):</label>
                        <input type="text" id="certifications" placeholder="e.g., USDA Organic, Fair Trade">
                    </div>
                    <button type="submit">Register Product</button>
                </form>
            </div>
        </div>

        <!-- Track Product Tab (Always accessible) -->
        <div id="track" class="tab-content">
            <h2>Track Product</h2>
            <div class="track-section">
                <div class="track-form">
                    <div class="form-group">
                        <label for="trackProductId">Product ID:</label>
                        <input type="number" id="trackProductId" required>
                    </div>
                    <button onclick="trackProduct()">Track Product</button>
                </div>
                <div style="margin-top: 15px; color: #666; font-size: 14px;">
                    <strong>Note:</strong> This will open the product details in a new page.
                </div>
                <div>
                    <!-- Add this button in your track section -->
<button onclick="debugProductStructure()" style="background: #17a2b8; margin-left: 10px;">Debug Products</button>
                </div>
            </div>
        </div>

        <!-- Transport Tab -->
        <div id="transport" class="tab-content">
            <div id="transportAccess">
                <h2>Record Transport</h2>
                <form id="transportForm">
                    <div class="grid">
                        <div class="form-group">
                            <label for="transportProductId">Product ID:</label>
                            <input type="number" id="transportProductId" required>
                        </div>
                        <div class="form-group">
                            <label for="vehicleId">Vehicle ID:</label>
                            <input type="text" id="vehicleId" required>
                        </div>
                        <div class="form-group">
                            <label for="transportOrigin">Origin:</label>
                            <input type="text" id="transportOrigin" required>
                        </div>
                        <div class="form-group">
                            <label for="destination">Destination:</label>
                            <input type="text" id="destination" required>
                        </div>
                        <div class="form-group">
                            <label for="temperature">Temperature (¬∞C):</label>
                            <input type="number" id="temperature" required>
                        </div>
                        <div class="form-group">
                            <label for="humidity">Humidity (%):</label>
                            <input type="number" id="humidity" required>
                        </div>
                    </div>
                    <button type="submit">Record Transport</button>
                </form>
                
                <div class="form-group" style="margin-top: 30px;">
                    <h3>Complete Transport</h3>
                    <label for="completeTransportId">Product ID:</label>
                    <input type="number" id="completeTransportId" required>
                    <button onclick="completeTransport()">Complete Transport</button>
                </div>
            </div>
        </div>

        <!-- Quality Test Tab -->
        <div id="quality" class="tab-content">
            <div id="qualityAccess">
                <h2>Add Quality Test</h2>
                <form id="qualityForm">
                    <div class="grid">
                        <div class="form-group">
                            <label for="qualityProductId">Product ID:</label>
                            <input type="number" id="qualityProductId" required>
                        </div>
                        <div class="form-group">
    <label for="testType">Test Type:</label>
    <select id="testType" required>
        <option value="">Select Test Type</option>
        <option value="Pesticide Residue Analysis">Pesticide Residue Analysis</option>
        <option value="Heavy Metal Detection">Heavy Metal Detection</option>
        <option value="Microbiological Testing">Microbiological Testing</option>
        <option value="Mycotoxin Testing">Mycotoxin Testing</option>
        <option value="Nutritional Analysis">Nutritional Analysis</option>
        <option value="Moisture Content Test">Moisture Content Test</option>
        <option value="pH Level Testing">pH Level Testing</option>
        <option value="Sugar Content (Brix) Test">Sugar Content (Brix) Test</option>
        <option value="Protein Content Analysis">Protein Content Analysis</option>
        <option value="Fat Content Analysis">Fat Content Analysis</option>
        <option value="Fiber Content Testing">Fiber Content Testing</option>
        <option value="Vitamin Content Analysis">Vitamin Content Analysis</option>
        <option value="Mineral Content Testing">Mineral Content Testing</option>
        <option value="Organic Certification Test">Organic Certification Test</option>
        <option value="GMO Detection Test">GMO Detection Test</option>
        <option value="Shelf Life Testing">Shelf Life Testing</option>
        <option value="Color Quality Assessment">Color Quality Assessment</option>
        <option value="Texture Analysis">Texture Analysis</option>
        <option value="Sensory Evaluation">Sensory Evaluation</option>
        <option value="Allergen Testing">Allergen Testing</option>
    </select>
</div>
                        <div class="form-group">
                            <label for="testResults">Test Results:</label>
                            <textarea id="testResults" required></textarea>
                        </div>
                        <div class="form-group">
                            <label for="testPassed">Test Passed:</label>
                            <select id="testPassed">
                                <option value="true">Yes</option>
                                <option value="false">No</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="laboratoryName">Laboratory Name:</label>
                            <input type="text" id="laboratoryName" required>
                        </div>
                    </div>
                    <button type="submit">Add Quality Test</button>
                </form>
            </div>
        </div>

        <!-- Create Batch Tab -->
        <div id="batch" class="tab-content">
            <div id="batchAccess">
                <h2>Create Batch</h2>
                <form id="batchForm">
                    <div class="grid">
                        <div class="form-group">
                            <label for="productIds">Product IDs (comma-separated):</label>
                            <input type="text" id="productIds" required placeholder="e.g., 1,2,3">
                        </div>
                        <div class="form-group">
                            <label for="processingFacility">Processing Facility:</label>
                            <input type="text" id="processingFacility" required>
                        </div>
                        <div class="form-group">
                            <label for="expiryDate">Expiry Date:</label>
                            <input type="date" id="expiryDate" required>
                        </div>
                        <div class="form-group">
                            <label for="packageType">Package Type:</label>
                            <input type="text" id="packageType" required>
                        </div>
                        <div class="form-group">
                            <label for="quantity">Quantity:</label>
                            <input type="number" id="quantity" required>
                        </div>
                    </div>
                    <button type="submit">Create Batch</button>
                </form>
            </div>
        </div>

        <!-- Stakeholder Tab -->
        <div id="stakeholder" class="tab-content">
            <h2>Register Stakeholder</h2>
            
            <!-- Current wallet info -->
            <div class="wallet-info" id="currentWalletInfo"></div>
            
            <!-- Status check section -->
            <div style="background: #f8f9fa; border: 2px dashed #6c757d; border-radius: 10px; padding: 15px; margin-bottom: 20px;">
                <h4>üîç Check Current Registration Status</h4>
                <button onclick="checkCurrentStatus()" style="background: #17a2b8; margin-right: 10px;">Check My Status</button>
                <div id="statusResult" style="margin-top: 10px; font-family: monospace; background: #343a40; color: #fff; padding: 10px; border-radius: 5px; display: none;"></div>
            </div>
            
            <form id="stakeholderForm">
                <div class="grid">
                    <div class="form-group">
                        <label for="stakeholderAddress">Stakeholder Address:</label>
                        <input type="text" id="stakeholderAddress" required placeholder="0x... (leave empty to use your address)">
                    </div>
                    <div class="form-group">
                        <label for="role">Role:</label>
                        <select id="role">
                            <option value="Farmer">Farmer</option>
                            <option value="Processor">Processor</option>
                            <option value="Distributor">Distributor</option>
                            <option value="Retailer">Retailer</option>
                            <option value="Quality Inspector">Quality Inspector</option>
                        </select>
                    </div>
                </div>
                <button type="submit">Register Stakeholder</button>
            </form>
            
            <div class="form-group" style="margin-top: 30px;">
                <h3>Authorize Tester</h3>
                <label for="testerAddress">Tester Address:</label>
                <input type="text" id="testerAddress" required placeholder="0x...">
                <button onclick="authorizeTester()">Authorize Tester</button>
            </div>

            <!-- Multi-stakeholder management section -->
            <div style="background: #e8f5e8; border: 2px solid #27ae60; border-radius: 15px; padding: 20px; margin: 30px 0;">
                <h3 style="color: #27ae60; margin-bottom: 15px;">üë• Multi-Stakeholder Registration Guide</h3>
                <p style="margin-bottom: 15px; color: #2d5d31;">
                    To register multiple stakeholders with different roles:
                </p>
                <ol style="color: #2d5d31; margin-left: 20px; line-height: 1.8;">
                    <li>Register your first stakeholder role above</li>
                    <li>Use the "Logout" button in the top-right or user info section</li>
                    <li>Connect with a different MetaMask account</li>
                    <li>Register the new account with a different role</li>
                    <li>Repeat as needed for all your stakeholder accounts</li>
                </ol>
                <div style="margin-top: 15px; padding: 10px; background: rgba(255, 255, 255, 0.7); border-radius: 8px;">
                    <strong>Tip:</strong> Use different browser profiles or MetaMask accounts to simulate different stakeholders in the supply chain.
                </div>
            </div>
        </div>

        <div id="status"></div>
    </div>
    
    <button onclick="window.open('qr_generator.html', '_blank')" style="position: fixed; bottom: 80px; right: 20px; z-index: 1001;">
        üì± Generate QR Codes
    </button>

    <script>
        // IMPORTANT: Replace this with your deployed contract address
        const CONTRACT_ADDRESS = "0x74d6683560a8A09bafBC2B1D0a7A47b6fdf4e8cC";
        
        // Complete CONTRACT_ABI - Replace the entire CONTRACT_ABI array in your index.html with this:

const CONTRACT_ABI = [
    {
        "inputs": [],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "address", "name": "previousOwner", "type": "address"},
            {"indexed": true, "internalType": "address", "name": "newOwner", "type": "address"}
        ],
        "name": "OwnershipTransferred",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "productId", "type": "uint256"},
            {"indexed": false, "internalType": "string", "name": "name", "type": "string"},
            {"indexed": true, "internalType": "address", "name": "farmer", "type": "address"}
        ],
        "name": "ProductRegistered",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "productId", "type": "uint256"},
            {"indexed": false, "internalType": "enum AgriTraceability.ProductStatus", "name": "status", "type": "uint8"}
        ],
        "name": "ProductStatusUpdated",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "productId", "type": "uint256"},
            {"indexed": false, "internalType": "bool", "name": "passed", "type": "bool"}
        ],
        "name": "QualityTestAdded",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "address", "name": "stakeholder", "type": "address"},
            {"indexed": false, "internalType": "string", "name": "role", "type": "string"}
        ],
        "name": "StakeholderRegistered",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "address", "name": "tester", "type": "address"}
        ],
        "name": "TesterAuthorized",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "productId", "type": "uint256"},
            {"indexed": false, "internalType": "address", "name": "carrier", "type": "address"}
        ],
        "name": "TransportRecorded",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "productId", "type": "uint256"}
        ],
        "name": "TransportCompleted",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {"indexed": true, "internalType": "uint256", "name": "batchId", "type": "uint256"},
            {"indexed": true, "internalType": "address", "name": "processor", "type": "address"},
            {"indexed": false, "internalType": "string", "name": "processingFacility", "type": "string"},
            {"indexed": false, "internalType": "uint256", "name": "quantity", "type": "uint256"},
            {"indexed": false, "internalType": "uint256[]", "name": "productIds", "type": "uint256[]"}
        ],
        "name": "BatchCreated",
        "type": "event"
    },
    {
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"}
        ],
        "name": "authorizedTesters",
        "outputs": [
            {"internalType": "bool", "name": "", "type": "bool"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "batchCounter",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "name": "batches",
        "outputs": [
            {"internalType": "uint256", "name": "id", "type": "uint256"},
            {"internalType": "string", "name": "processingFacility", "type": "string"},
            {"internalType": "uint256", "name": "creationDate", "type": "uint256"},
            {"internalType": "uint256", "name": "expiryDate", "type": "uint256"},
            {"internalType": "string", "name": "packageType", "type": "string"},
            {"internalType": "uint256", "name": "quantity", "type": "uint256"},
            {"internalType": "address", "name": "processor", "type": "address"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "owner",
        "outputs": [
            {"internalType": "address", "name": "", "type": "address"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "productCounter",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "name": "productInBatch",
        "outputs": [
            {"internalType": "bool", "name": "", "type": "bool"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "name": "productToBatches",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "name": "products",
        "outputs": [
            {"internalType": "uint256", "name": "id", "type": "uint256"},
            {"internalType": "string", "name": "name", "type": "string"},
            {"internalType": "string", "name": "variety", "type": "string"},
            {"internalType": "string", "name": "origin", "type": "string"},
            {"internalType": "bool", "name": "isOrganic", "type": "bool"},
            {"internalType": "enum AgriTraceability.ProductStatus", "name": "status", "type": "uint8"},
            {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
            {"internalType": "address", "name": "farmer", "type": "address"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "name": "qualityTests",
        "outputs": [
            {"internalType": "string", "name": "testType", "type": "string"},
            {"internalType": "string", "name": "results", "type": "string"},
            {"internalType": "bool", "name": "passed", "type": "bool"},
            {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
            {"internalType": "address", "name": "tester", "type": "address"},
            {"internalType": "string", "name": "laboratoryName", "type": "string"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"}
        ],
        "name": "stakeholders",
        "outputs": [
            {"internalType": "string", "name": "role", "type": "string"},
            {"internalType": "bool", "name": "isRegistered", "type": "bool"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "name": "transports",
        "outputs": [
            {"internalType": "string", "name": "vehicleId", "type": "string"},
            {"internalType": "string", "name": "origin", "type": "string"},
            {"internalType": "string", "name": "destination", "type": "string"},
            {"internalType": "int256", "name": "temperature", "type": "int256"},
            {"internalType": "uint256", "name": "humidity", "type": "uint256"},
            {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
            {"internalType": "address", "name": "carrier", "type": "address"},
            {"internalType": "bool", "name": "completed", "type": "bool"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "string", "name": "_role", "type": "string"}
        ],
        "name": "registerStakeholder",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
           "inputs": [
        {"internalType": "string", "name": "_name", "type": "string"},
        {"internalType": "string", "name": "_variety", "type": "string"},
        {"internalType": "string", "name": "_origin", "type": "string"},
        {"internalType": "uint256", "name": "_plantedDate", "type": "uint256"},
        {"internalType": "uint256", "name": "_harvestedDate", "type": "uint256"},
        {"internalType": "bool", "name": "_isOrganic", "type": "bool"},
        {"internalType": "string[]", "name": "_certifications", "type": "string[]"}
    ],
    "name": "registerProduct",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
        },
    {
    "inputs": [
        {"internalType": "uint256", "name": "_productId", "type": "uint256"}
    ],
    "name": "getProduct",
    "outputs": [
        {
            "components": [
                {"internalType": "uint256", "name": "id", "type": "uint256"},
                {"internalType": "string", "name": "name", "type": "string"},
                {"internalType": "string", "name": "variety", "type": "string"},
                {"internalType": "string", "name": "origin", "type": "string"},
                {"internalType": "bool", "name": "isOrganic", "type": "bool"},
                {"internalType": "string[]", "name": "certifications", "type": "string[]"},
                {"internalType": "enum AgriTraceability.ProductStatus", "name": "status", "type": "uint8"},
                {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                {"internalType": "address", "name": "farmer", "type": "address"},
                {"internalType": "uint256", "name": "plantedDate", "type": "uint256"},
                {"internalType": "uint256", "name": "harvestDate", "type": "uint256"}
            ],
            "internalType": "struct AgriTraceability.Product",
            "name": "",
            "type": "tuple"
        }
    ],
    "stateMutability": "view",
    "type": "function"
}, 
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"},
            {"internalType": "string", "name": "_vehicleId", "type": "string"},
            {"internalType": "string", "name": "_origin", "type": "string"},
            {"internalType": "string", "name": "_destination", "type": "string"},
            {"internalType": "int256", "name": "_temperature", "type": "int256"},
            {"internalType": "uint256", "name": "_humidity", "type": "uint256"}
        ],
        "name": "recordTransport",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"}
        ],
        "name": "completeTransport",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"},
            {"internalType": "string", "name": "_testType", "type": "string"},
            {"internalType": "string", "name": "_results", "type": "string"},
            {"internalType": "bool", "name": "_passed", "type": "bool"},
            {"internalType": "string", "name": "_laboratoryName", "type": "string"}
        ],
        "name": "addQualityTest",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256[]", "name": "_productIds", "type": "uint256[]"},
            {"internalType": "string", "name": "_processingFacility", "type": "string"},
            {"internalType": "uint256", "name": "_expiryDate", "type": "uint256"},
            {"internalType": "string", "name": "_packageType", "type": "string"},
            {"internalType": "uint256", "name": "_quantity", "type": "uint256"}
        ],
        "name": "createBatch",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_batchId", "type": "uint256"}
        ],
        "name": "getBatch",
        "outputs": [
            {
                "components": [
                    {"internalType": "uint256", "name": "id", "type": "uint256"},
                    {"internalType": "uint256[]", "name": "productIds", "type": "uint256[]"},
                    {"internalType": "string", "name": "processingFacility", "type": "string"},
                    {"internalType": "uint256", "name": "creationDate", "type": "uint256"},
                    {"internalType": "uint256", "name": "expiryDate", "type": "uint256"},
                    {"internalType": "string", "name": "packageType", "type": "string"},
                    {"internalType": "uint256", "name": "quantity", "type": "uint256"},
                    {"internalType": "address", "name": "processor", "type": "address"}
                ],
                "internalType": "struct AgriTraceability.Batch",
                "name": "",
                "type": "tuple"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"}
        ],
        "name": "getProductBatches",
        "outputs": [
            {"internalType": "uint256[]", "name": "", "type": "uint256[]"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"},
            {"internalType": "uint256", "name": "_batchId", "type": "uint256"}
        ],
        "name": "isProductInBatch",
        "outputs": [
            {"internalType": "bool", "name": "", "type": "bool"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"}
        ],
        "name": "getQualityTests",
        "outputs": [
            {
                "components": [
                    {"internalType": "string", "name": "testType", "type": "string"},
                    {"internalType": "string", "name": "results", "type": "string"},
                    {"internalType": "bool", "name": "passed", "type": "bool"},
                    {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                    {"internalType": "address", "name": "tester", "type": "address"},
                    {"internalType": "string", "name": "laboratoryName", "type": "string"}
                ],
                "internalType": "struct AgriTraceability.QualityTest[]",
                "name": "",
                "type": "tuple[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"}
        ],
        "name": "getTransports",
        "outputs": [
            {
                "components": [
                    {"internalType": "string", "name": "vehicleId", "type": "string"},
                    {"internalType": "string", "name": "origin", "type": "string"},
                    {"internalType": "string", "name": "destination", "type": "string"},
                    {"internalType": "int256", "name": "temperature", "type": "int256"},
                    {"internalType": "uint256", "name": "humidity", "type": "uint256"},
                    {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                    {"internalType": "address", "name": "carrier", "type": "address"},
                    {"internalType": "bool", "name": "completed", "type": "bool"}
                ],
                "internalType": "struct AgriTraceability.Transport[]",
                "name": "",
                "type": "tuple[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "address", "name": "_tester", "type": "address"}
        ],
        "name": "authorizeTester",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "address", "name": "_tester", "type": "address"}
        ],
        "name": "revokeTester",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"},
            {"internalType": "enum AgriTraceability.ProductStatus", "name": "_status", "type": "uint8"}
        ],
        "name": "updateProductStatus",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_productId", "type": "uint256"},
            {"internalType": "string", "name": "_reason", "type": "string"}
        ],
        "name": "recallProduct",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "getTotalProducts",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "getTotalBatches",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {"internalType": "address", "name": "newOwner", "type": "address"}
        ],
        "name": "transferOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
];

        let web3;
        let contract;
        let accounts = [];
        let currentUserRole = null;
        let isRoleChecked = false;
        let initializationPromise = null;
        let debugLog = [];
        let isConnected = false;

        // Enhanced logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toISOString();
            debugLog.push(`[${timestamp}] ${type.toUpperCase()}: ${message}`);
            console.log(`[${type}] ${message}`);
            
            // Keep only last 50 logs
            if (debugLog.length > 50) {
                debugLog = debugLog.slice(-50);
            }
        }

        // Role-based access control configuration
        const ROLE_ACCESS = {
            'Farmer': ['register', 'track'],
            'Processor': ['batch', 'track'],
            'Distributor': ['transport', 'track'],
            'Retailer': ['track'],
            'Quality Inspector': ['quality', 'track'],
            'Admin': ['register', 'track', 'transport', 'quality', 'batch', 'stakeholder']
        };

        // Status mappings
        const STATUS_NAMES = {
            0: 'Harvested',
            1: 'Processing',
            2: 'Packaged',
            3: 'Shipped',
            4: 'Delivered',
            5: 'Recalled'
        };

        const GRADE_NAMES = {
            0: 'A',
            1: 'B',
            2: 'C'
        };

        // Network information
        const NETWORKS = {
            1: 'Ethereum Mainnet',
            3: 'Ropsten Testnet',
            4: 'Rinkeby Testnet',
            5: 'Goerli Testnet',
            11155111: 'Sepolia Testnet',
            137: 'Polygon Mainnet',
            80001: 'Polygon Mumbai',
            56: 'BSC Mainnet',
            97: 'BSC Testnet',
            43114: 'Avalanche Mainnet',
            43113: 'Avalanche Fuji',
            42161: 'Arbitrum One',
            421613: 'Arbitrum Goerli',
            10: 'Optimism',
            420: 'Optimism Goerli',
            1337: 'Localhost',
            5777: 'Ganache'
        };

        // NEW LOGOUT FUNCTIONALITY

        // Enhanced wallet connection function
        async function connectWallet() {
            try {
                updateConnectionStatus('Connecting...');
                log('User initiated wallet connection', 'info');
                
                if (typeof window.ethereum === 'undefined') {
                    throw new Error('MetaMask not found. Please install MetaMask.');
                }

                // Request account access
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                // Initialize Web3
                await initWeb3();
                
            } catch (error) {
                log('Error connecting wallet: ' + error.message, 'error');
                showStatus('‚ùå Failed to connect wallet: ' + error.message, 'error');
                updateConnectionStatus(false);
            }
        }

        // Switch account function
        async function switchAccount() {
            try {
                log('User initiated account switch', 'info');
                showStatus('üîÑ Please select a different account in MetaMask...', 'info');
                
                if (typeof window.ethereum === 'undefined') {
                    throw new Error('MetaMask not found.');
                }

                // Request to switch accounts in MetaMask
                await window.ethereum.request({
                    method: 'wallet_requestPermissions',
                    params: [{ eth_accounts: {} }]
                });
                
            } catch (error) {
                log('Error switching account: ' + error.message, 'error');
                showStatus('‚ùå Failed to switch account: ' + error.message, 'error');
            }
        }

        // Enhanced disconnect function
        async function disconnectWallet() {
            try {
                log('User initiated wallet disconnection', 'info');
                
                // Reset all application state
                resetApplicationState();
                
                // Update UI to show disconnected state
                updateUIForDisconnectedState();
                
                showStatus('üö™ Wallet disconnected successfully. You can now connect with a different account.', 'success');
                
            } catch (error) {
                log('Error during disconnect: ' + error.message, 'error');
                showStatus('‚ùå Error during disconnect: ' + error.message, 'error');
            }
        }

        // Logout user function (alternative name for disconnect)
        function logoutUser() {
            log('User clicked logout button', 'info');
            disconnectWallet();
        }

        // Reset application state
        function resetApplicationState() {
            log('Resetting application state', 'info');
            
            // Clear Web3 and contract instances
            web3 = null;
            contract = null;
            accounts = [];
            currentUserRole = null;
            isRoleChecked = false;
            initializationPromise = null;
            isConnected = false;
            
            // Clear any pending transactions or timeouts
            // (Add any cleanup code here if needed)
        }

        // Update UI for disconnected state
        function updateUIForDisconnectedState() {
            log('Updating UI for disconnected state', 'info');
            
            // Update connection status
            updateConnectionStatus(false);
            
            // Hide user info and show wallet section
            const userInfoDiv = document.getElementById('userInfo');
            const walletSection = document.getElementById('walletSection');
            const rolePrompt = document.getElementById('rolePrompt');
            
            userInfoDiv.style.display = 'none';
            walletSection.style.display = 'block';
            rolePrompt.style.display = 'none';
            
            // Update wallet controls
            updateWalletControls(false);
            
            // Disable all tabs except basic ones
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.classList.add('disabled');
                tab.style.pointerEvents = 'none';
                tab.title = 'Please connect your wallet first';
            });
            
            // Clear current wallet info
            const walletInfo = document.getElementById('currentWalletInfo');
            if (walletInfo) {
                walletInfo.textContent = 'No wallet connected';
            }
            
            // Reset to default tab
            showTab('register');
        }

        // Update wallet controls visibility
        function updateWalletControls(connected) {
            const connectBtn = document.getElementById('connectBtn');
            const switchBtn = document.getElementById('switchBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (connected) {
                connectBtn.style.display = 'none';
                switchBtn.style.display = 'block';
                disconnectBtn.style.display = 'block';
            } else {
                connectBtn.style.display = 'block';
                switchBtn.style.display = 'none';
                disconnectBtn.style.display = 'none';
            }
        }

        // Update current wallet info display
        function updateCurrentWalletInfo() {
            const walletInfo = document.getElementById('currentWalletInfo');
            if (walletInfo && accounts && accounts.length > 0) {
                walletInfo.innerHTML = `
                    <strong>Current Wallet:</strong> ${accounts[0]}<br>
                    <strong>Role:</strong> ${currentUserRole || 'Unregistered'}<br>
                    <strong>Status:</strong> ${isConnected ? 'Connected' : 'Disconnected'}
                `;
            }
        }

        // EXISTING FUNCTIONS (keeping all the original functionality)

        async function getNetworkInfo() {
            try {
                if (!web3) {
                    log('Web3 not initialized', 'error');
                    return { networkId: null, networkName: 'Web3 not initialized' };
                }
                
                const networkId = await web3.eth.net.getId();
                const networkName = NETWORKS[networkId] || `Unknown Network (${networkId})`;
                log(`Network detected: ${networkName} (${networkId})`, 'info');
                return { networkId, networkName };
            } catch (error) {
                log('Error getting network info: ' + error.message, 'error');
                return { networkId: null, networkName: 'Error: ' + error.message };
            }
        }

        async function checkContractDeployment() {
            try {
                if (!web3) {
                    log('Web3 not initialized for contract check', 'error');
                    return false;
                }
                
                const code = await web3.eth.getCode(CONTRACT_ADDRESS);
                log(`Contract code at ${CONTRACT_ADDRESS}: ${code.substring(0, 50)}...`, 'info');
                
                if (code === '0x' || code === '0x0') {
                    log('No contract found at the specified address', 'error');
                    return false;
                }
                
                log('Contract found at address', 'success');
                return true;
                
            } catch (error) {
                log('Error checking contract deployment: ' + error.message, 'error');
                return false;
            }
        }

        // Enhanced user role checking with better error handling
        async function checkUserRole() {
            if (!contract || !accounts || accounts.length === 0) {
                log('Cannot check user role: missing contract or accounts', 'warning');
                return null;
            }

            try {
                log('Checking role for address: ' + accounts[0], 'info');
                const stakeholderInfo = await contract.methods.stakeholders(accounts[0]).call();
                
                if (stakeholderInfo && stakeholderInfo.isRegistered && stakeholderInfo.role && stakeholderInfo.role.trim() !== '') {
                    log('User role found: ' + stakeholderInfo.role, 'success');
                    return stakeholderInfo.role.toString().trim();
                }
                
                log('No role found for user', 'info');
                return null;
                
            } catch (error) {
                log('Error checking user role: ' + error.message, 'error');
                return null;
            }
        }

        // Update UI based on user role
        async function updateUIForRole() {
            log('Updating UI for role. isRoleChecked: ' + isRoleChecked + ', currentUserRole: ' + currentUserRole, 'info');
            
            if (!isRoleChecked) {
                currentUserRole = await checkUserRole();
                isRoleChecked = true;
                log('Role check completed. Current role: ' + currentUserRole, 'info');
            }

            const userInfoDiv = document.getElementById('userInfo');
            const walletSection = document.getElementById('walletSection');
            const rolePromptDiv = document.getElementById('rolePrompt');
            const tabs = document.querySelectorAll('.tab');
            
            // Hide wallet connection section when connected
            walletSection.style.display = 'none';
            
            if (currentUserRole) {
                userInfoDiv.style.display = 'block';
                userInfoDiv.innerHTML = `
                    üë§ Logged in as: <strong>${currentUserRole}</strong> (${accounts[0].substring(0, 8)}...)
                    <button onclick="logoutUser()" class="logout-btn">Logout</button>
                `;
                rolePromptDiv.style.display = 'none';

                const allowedTabs = ROLE_ACCESS[currentUserRole] || ['track'];
                log('Allowed tabs for ' + currentUserRole + ': ' + allowedTabs.join(', '), 'info');
                
                tabs.forEach(tab => {
                    const onclickAttr = tab.getAttribute('onclick');
                    if (onclickAttr) {
                        const tabNameMatch = onclickAttr.match(/'([^']+)'/);
                        if (tabNameMatch) {
                            const tabName = tabNameMatch[1];
                            
                            if (allowedTabs.includes(tabName)) {
                                tab.classList.remove('disabled');
                                tab.style.pointerEvents = 'auto';
                                tab.title = '';
                            } else {
                                tab.classList.add('disabled');
                                tab.style.pointerEvents = 'none';
                                tab.title = `Access restricted. Your role: ${currentUserRole}`;
                            }
                        }
                    }
                });

                updateTabContentAccess(allowedTabs);
                
            } else {
                userInfoDiv.style.display = 'block';
                userInfoDiv.innerHTML = `
                    ‚ö†Ô∏è Connected as: <strong>Unregistered User</strong> (${accounts[0].substring(0, 8)}...)
                    <button onclick="logoutUser()" class="logout-btn">Logout</button>
                `;
                rolePromptDiv.style.display = 'block';

                tabs.forEach(tab => {
                    const onclickAttr = tab.getAttribute('onclick');
                    if (onclickAttr) {
                        const tabNameMatch = onclickAttr.match(/'([^']+)'/);
                        if (tabNameMatch) {
                            const tabName = tabNameMatch[1];
                            
                            if (tabName === 'track' || tabName === 'stakeholder') {
                                tab.classList.remove('disabled');
                                tab.style.pointerEvents = 'auto';
                                tab.title = '';
                            } else {
                                tab.classList.add('disabled');
                                tab.style.pointerEvents = 'none';
                                tab.title = 'Please register as a stakeholder first';
                            }
                        }
                    }
                });

                updateTabContentAccess(['track', 'stakeholder']);
            }
            
            // Update current wallet info
            updateCurrentWalletInfo();
            
            // Update wallet controls
            updateWalletControls(true);
        }

        // Update tab content based on access
        function updateTabContentAccess(allowedTabs) {
            const tabContents = ['register', 'transport', 'quality', 'batch'];
            
            tabContents.forEach(tabName => {
                const accessDiv = document.getElementById(tabName + 'Access');
                const tabContent = document.getElementById(tabName);
                
                if (accessDiv) {
                    if (allowedTabs.includes(tabName)) {
                        accessDiv.style.display = 'block';
                    } else {
                        accessDiv.style.display = 'none';
                        tabContent.innerHTML = `
                            <div class="access-denied">
                                <h2>üö´ Access Denied</h2>
                                <p>You don't have permission to access this feature.</p>
                                <p>Your current role: <strong>${currentUserRole || 'Unregistered'}</strong></p>
                                <p>Required roles for this feature: <strong>${getRequiredRoles(tabName)}</strong></p>
                                <button onclick="logoutUser()" style="margin-top: 15px;">üö™ Switch Account</button>
                            </div>
                        `;
                    }
                }
            });
        }

        // Get required roles for a specific tab
        function getRequiredRoles(tabName) {
            const roles = [];
            for (const [role, tabs] of Object.entries(ROLE_ACCESS)) {
                if (tabs.includes(tabName)) {
                    roles.push(role);
                }
            }
            return roles.join(', ');
        }

        // Enhanced Web3 initialization with proper error handling
        async function initWeb3() {
            // Prevent multiple simultaneous initializations
            if (initializationPromise) {
                return initializationPromise;
            }

            initializationPromise = (async () => {
                log('Starting Web3 initialization...', 'info');
                updateConnectionStatus('Connecting...');

                try {
                    if (typeof window.ethereum === 'undefined') {
                        throw new Error('MetaMask not found. Please install MetaMask.');
                    }

                    log('MetaMask detected, initializing Web3...', 'info');
                    web3 = new Web3(window.ethereum);
                    
                    log('Requesting account access...', 'info');
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    accounts = await web3.eth.getAccounts();
                    
                    if (accounts.length === 0) {
                        throw new Error('No accounts found. Please connect your MetaMask wallet.');
                    }
                    
                    log('Connected account: ' + accounts[0], 'success');
                    
                    const { networkId, networkName } = await getNetworkInfo();
                    
                    if (CONTRACT_ADDRESS === "YOUR_DEPLOYED_CONTRACT_ADDRESS_HERE") {
                        throw new Error('Contract address not configured. Please update CONTRACT_ADDRESS.');
                    }

                    const contractExists = await checkContractDeployment();
                    if (!contractExists) {
                        throw new Error(`No contract found at ${CONTRACT_ADDRESS}. Please verify the contract is deployed on ${networkName}.`);
                    }

                    log('Initializing contract...', 'info');
                    contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                    
                    // Test contract call
                    try {
                        log('Testing basic contract call...', 'info');
                        await contract.methods.stakeholders(accounts[0]).call();
                        log('Contract test call successful', 'success');
                    } catch (contractError) {
                        log('Contract test call failed: ' + contractError.message, 'warning');
                    }
                    
                    isConnected = true;
                    updateConnectionStatus(true);
                    showStatus(`‚úÖ Connected to ${networkName}! Contract loaded successfully.`, 'success');
                    
                    await updateUIForRole();
                    return true;
                    
                } catch (error) {
                    log('Error in Web3 initialization: ' + error.message, 'error');
                    updateConnectionStatus(false);
                    showStatus('‚ùå Connection Error: ' + error.message, 'error');
                    isConnected = false;
                    
                    // Show wallet section on connection failure
                    document.getElementById('walletSection').style.display = 'block';
                    updateWalletControls(false);
                    
                    return false;
                }
            })();

            return initializationPromise;
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            if (status === true) {
                statusElement.textContent = 'üü¢ Connected';
                statusElement.className = 'connection-status connected';
            } else if (status === false) {
                statusElement.textContent = 'üî¥ Disconnected';
                statusElement.className = 'connection-status disconnected';
            } else {
                statusElement.textContent = 'üü° ' + status;
                statusElement.className = 'connection-status';
                statusElement.style.background = 'linear-gradient(45deg, #f39c12, #e67e22)';
                statusElement.style.color = 'white';
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 8000);
        }

        // Enhanced status checking with validation
        async function checkCurrentStatus() {
            const statusDiv = document.getElementById('statusResult');
            statusDiv.style.display = 'block';
            statusDiv.textContent = 'Checking status...';

            try {
                // Wait for initialization if needed
                if (!web3 || !contract || accounts.length === 0) {
                    statusDiv.textContent = 'Web3 not properly initialized. Please connect your wallet.';
                    log('Web3 not initialized in checkCurrentStatus', 'warning');
                    return;
                }

                const checkAddress = accounts[0];
                log('Checking status for: ' + checkAddress, 'info');
                
                const stakeholderInfo = await contract.methods.stakeholders(checkAddress).call();
                
                const result = {
                    'Address': checkAddress,
                    'Is Registered': stakeholderInfo.isRegistered,
                    'Role': stakeholderInfo.role,
                    'Status': stakeholderInfo.isRegistered ? `Registered as ${stakeholderInfo.role}` : 'Not registered',
                    'Timestamp': new Date().toISOString()
                };
                
                statusDiv.textContent = JSON.stringify(result, null, 2);
                
                if (stakeholderInfo.isRegistered) {
                    showStatus(`‚úÖ You are registered as: ${stakeholderInfo.role}`, 'success');
                } else {
                    showStatus('‚ÑπÔ∏è You are not registered as a stakeholder', 'info');
                }
                
            } catch (error) {
                log('Error checking status: ' + error.message, 'error');
                statusDiv.textContent = `Error: ${error.message}\n\nPlease ensure:\n1. MetaMask is connected\n2. You're on the correct network\n3. Contract is deployed properly`;
                showStatus('Error checking status: ' + error.message, 'error');
            }
        }

        // Force reconnection utility
        async function forceReconnect() {
            log('Force reconnection initiated...', 'info');
            
            // Reset all state
            resetApplicationState();
            
            updateConnectionStatus('Reconnecting...');
            
            try {
                const success = await initWeb3();
                if (success) {
                    showStatus('üîÑ Reconnection successful!', 'success');
                } else {
                    showStatus('‚ùå Reconnection failed. Please check your wallet and try again.', 'error');
                    updateUIForDisconnectedState();
                }
            } catch (error) {
                log('Reconnection error: ' + error.message, 'error');
                showStatus('‚ùå Reconnection error: ' + error.message, 'error');
                updateUIForDisconnectedState();
            }
        }

        // Debug information display
        function showDebugInfo() {
            const info = {
                'Web3 Available': !!web3,
                'Contract Available': !!contract,
                'Accounts': accounts,
                'Current Role': currentUserRole,
                'Initialization Complete': isRoleChecked,
                'Is Connected': isConnected,
                'Contract Address': CONTRACT_ADDRESS,
                'Recent Logs': debugLog.slice(-10)
            };
            
            alert('Debug Info:\n' + JSON.stringify(info, null, 2));
        }

        // Tab switching functionality
        function showTab(tabName) {
            const tab = document.querySelector(`[onclick*="${tabName}"]`);
            if (tab && tab.classList.contains('disabled')) {
                showStatus('‚ö†Ô∏è Access denied. You do not have permission to view this tab.', 'warning');
                return;
            }

            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });

            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });

            document.getElementById(tabName).classList.add('active');
            
            const clickedTab = document.querySelector(`[onclick*="${tabName}"]`);
            if (clickedTab) {
                clickedTab.classList.add('active');
            }
        }

        // Function to ensure Web3 is connected
        async function ensureWeb3Connected() {
            if (!web3 || !contract || !accounts || accounts.length === 0 || !isConnected) {
                showStatus('‚ö†Ô∏è Please connect to Web3 first. Use the Connect button if needed.', 'warning');
                log('Web3 not connected when trying to perform action', 'warning');
                return false;
            }
            return true;
        }

// Fixed Register Product Event Listener
document.getElementById('registerForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    if (!(await ensureWeb3Connected())) return;

    if (!currentUserRole || !ROLE_ACCESS[currentUserRole].includes('register')) {
        showStatus('‚ö†Ô∏è Access denied. You need Farmer or Admin role to register products.', 'error');
        return;
    }

    const name = document.getElementById('productName').value;
    const variety = document.getElementById('variety').value;
    const origin = document.getElementById('origin').value;
    const plantedDateInput = document.getElementById('plantedDate').value;
    const harvestedDateInput = document.getElementById('harvestedDate').value;
    const isOrganic = document.getElementById('isOrganic').value === 'true';
    const certificationsInput = document.getElementById('certifications').value;
    const certifications = certificationsInput ? certificationsInput.split(',').map(cert => cert.trim()) : [];

    // Enhanced date validation and conversion
    console.log('Input dates:', { plantedDateInput, harvestedDateInput });

    if (!plantedDateInput || !harvestedDateInput) {
        showStatus('‚ö†Ô∏è Please select both planted and harvested dates', 'error');
        return;
    }

    try {
        // Create Date objects and validate
        const plantedDateObj = new Date(plantedDateInput + 'T00:00:00Z'); // Add UTC timezone
        const harvestedDateObj = new Date(harvestedDateInput + 'T00:00:00Z');
        
        // Check if dates are valid
        if (isNaN(plantedDateObj.getTime()) || isNaN(harvestedDateObj.getTime())) {
            throw new Error('Invalid date format');
        }

        // Convert to Unix timestamps (seconds, not milliseconds)
        const plantedDate = Math.floor(plantedDateObj.getTime() / 1000);
        const harvestedDate = Math.floor(harvestedDateObj.getTime() / 1000);

        console.log('Converted timestamps:', { plantedDate, harvestedDate });

        // Validate dates
        if (plantedDate >= harvestedDate) {
            showStatus('‚ö†Ô∏è Harvested date must be after planted date', 'error');
            return;
        }

        // Additional validation: check if dates are reasonable
        const currentTimestamp = Math.floor(Date.now() / 1000);
        if (plantedDate > currentTimestamp) {
            showStatus('‚ö†Ô∏è Planted date cannot be in the future', 'error');
            return;
        }

        if (harvestedDate > currentTimestamp + (365 * 24 * 60 * 60)) { // More than 1 year in future
            showStatus('‚ö†Ô∏è Harvested date seems too far in the future', 'error');
            return;
        }

        // Validate other inputs
        if (!name.trim()) {
            showStatus('‚ö†Ô∏è Product name cannot be empty', 'error');
            return;
        }

        if (!variety.trim()) {
            showStatus('‚ö†Ô∏è Variety cannot be empty', 'error');
            return;
        }

        if (!origin.trim()) {
            showStatus('‚ö†Ô∏è Origin cannot be empty', 'error');
            return;
        }

        showStatus('üîÑ Registering product...', 'info');
        log('Registering product: ' + name + ' with dates: ' + plantedDate + ', ' + harvestedDate, 'info');
        
        // Call the contract with proper parameter order
        const result = await contract.methods.registerProduct(
            name,
            variety,
            origin,
            plantedDate,
            harvestedDate,
            isOrganic,
            certifications
        ).send({ 
            from: accounts[0],
            gas: 3000000 // Increase gas limit
        });
        
        // Get the product ID from the event
        let productId = 1;
        if (result && result.events && result.events.ProductRegistered) {
            productId = result.events.ProductRegistered.returnValues.productId;
        }
        
        log('Product registered successfully with ID: ' + productId, 'success');
        showStatus(`‚úÖ Product registered successfully! Product ID: ${productId}`, 'success');
        
        document.getElementById('registerForm').reset();
        
    } catch (dateError) {
        console.error('Date processing error:', dateError);
        if (dateError.message.includes('Invalid date')) {
            showStatus('‚ùå Invalid date format. Please select valid dates.', 'error');
        } else if (dateError.message.includes('BigNumber')) {
            showStatus('‚ùå Date conversion error. Please try selecting the dates again.', 'error');
        } else {
            log('Error registering product: ' + dateError.message, 'error');
            showStatus('‚ùå Error registering product: ' + dateError.message, 'error');
        }
    }
});

        // Track Product
         // Debug function to test different product IDs
async function debugProductStructure() {
    if (!(await ensureWeb3Connected())) return;
    
    console.log('Testing product structure...');
    for (let id = 0; id <= 5; id++) {
        try {
            const result = await contract.methods.getProduct(id).call();
            console.log(`Product ID ${id}:`, result);
        } catch (error) {
            console.log(`Product ID ${id}: Error -`, error.message);
        }
    }
}
        async function trackProduct() {
            const productId = document.getElementById('trackProductId').value;
            
            if (!productId) {
                showStatus('‚ö†Ô∏è Please enter a product ID', 'error');
                return;
            }

            if (!(await ensureWeb3Connected())) return;

            try {
                showStatus('üîÑ Validating product...', 'info');
                log('Validating product ID: ' + productId, 'info');
                
                try {
    showStatus('üîÑ Validating product...', 'info');
    log('Validating product ID: ' + productId, 'info');
    
    // First check if product exists by trying to get basic info
let productExists = false;
try {
    const productInfo = await contract.methods.getProduct(productId).call();
    console.log('Raw product data:', productInfo); // Debug log
    productExists = true; // If we get here, product exists
    
} catch (productError) {
    console.log('Product check error:', productError);
    
    // Check for specific contract revert messages
    if (productError.message.includes('Product does not exist') || 
        productError.message.includes('execution reverted') ||
        productError.message.includes('revert') ||
        productError.code === -32000) {
        productExists = false;
    } else {
        // Some other unexpected error occurred
        throw productError;
    }
}

if (!productExists) {
    showStatus(`‚ùå Product ID ${productId} has not been registered yet. Please register a product first or try a different ID.`, 'error');
    log('Product does not exist: ' + productId, 'error');
    return;
}
    
    const currentUrl = window.location.href;
    const baseUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
    const productDetailsUrl = `${baseUrl}product_details_updated.html?productId=${productId}&contractAddress=${CONTRACT_ADDRESS}`;
    
    showStatus('‚úÖ Product found! Opening details page...', 'success');
    log('Product validated, opening details page', 'success');
    window.open(productDetailsUrl, '_blank');
    
} catch (error) {
    log('Error validating product: ' + error.message, 'error');
    if (error.message.includes('BUFFER_OVERRUN') || error.message.includes('out-of-bounds')) {
        showStatus(`‚ùå Product ID ${productId} does not exist in the system`, 'error');
    } else {
        showStatus('‚ùå Error occurred while validating product: ' + error.message, 'error');
    }
}
                
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
                const productDetailsUrl = `${baseUrl}product_details_updated.html?productId=${productId}&contractAddress=${CONTRACT_ADDRESS}`;
                
                showStatus('‚úÖ Product found! Opening details page...', 'success');
                log('Product validated, opening details page', 'success');
                window.open(productDetailsUrl, '_blank');
                
            } catch (error) {
                log('Error validating product: ' + error.message, 'error');
                showStatus('‚ùå Product not found or error occurred: ' + error.message, 'error');
            }
        }

        // Record Transport
        document.getElementById('transportForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!(await ensureWeb3Connected())) return;

            if (!currentUserRole || !ROLE_ACCESS[currentUserRole].includes('transport')) {
                showStatus('‚ö†Ô∏è Access denied. You need Distributor or Admin role to record transport.', 'error');
                return;
            }

            const productId = document.getElementById('transportProductId').value;
            const vehicleId = document.getElementById('vehicleId').value;
            const origin = document.getElementById('transportOrigin').value;
            const destination = document.getElementById('destination').value;
            const temperature = document.getElementById('temperature').value;
            const humidity = document.getElementById('humidity').value;

            try {
                showStatus('üöö Recording transport...', 'info');
                log('Recording transport for product: ' + productId, 'info');
                
                await contract.methods.recordTransport(
                    productId, vehicleId, origin, destination, temperature, humidity
                ).send({ from: accounts[0] });
                
                log('Transport recorded successfully', 'success');
                showStatus('‚úÖ Transport recorded successfully!', 'success');
                document.getElementById('transportForm').reset();
            } catch (error) {
                log('Error recording transport: ' + error.message, 'error');
                showStatus('‚ùå Error recording transport: ' + error.message, 'error');
            }
        });

        // Complete Transport
        async function completeTransport() {
            const productId = document.getElementById('completeTransportId').value;
            
            if (!productId) {
                showStatus('‚ö†Ô∏è Please enter a product ID', 'error');
                return;
            }

            if (!(await ensureWeb3Connected())) return;

            if (!currentUserRole || !ROLE_ACCESS[currentUserRole].includes('transport')) {
                showStatus('‚ö†Ô∏è Access denied. You need Distributor or Admin role.', 'error');
                return;
            }

            try {
                showStatus('‚úÖ Completing transport...', 'info');
                log('Completing transport for product: ' + productId, 'info');
                
                await contract.methods.completeTransport(productId).send({ from: accounts[0] });
                
                log('Transport completed successfully', 'success');
                showStatus('‚úÖ Transport completed successfully!', 'success');
                document.getElementById('completeTransportId').value = '';
            } catch (error) {
                log('Error completing transport: ' + error.message, 'error');
                showStatus('‚ùå Error completing transport: ' + error.message, 'error');
            }
        }

        // Add Quality Test
        document.getElementById('qualityForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!(await ensureWeb3Connected())) return;

            if (!currentUserRole || !ROLE_ACCESS[currentUserRole].includes('quality')) {
                showStatus('‚ö†Ô∏è Access denied. You need Quality Inspector or Admin role.', 'error');
                return;
            }

            const productId = document.getElementById('qualityProductId').value;
            const testType = document.getElementById('testType').value;
            const results = document.getElementById('testResults').value;
            const passed = document.getElementById('testPassed').value === 'true';
            const laboratoryName = document.getElementById('laboratoryName').value;

            try {
                showStatus('üî¨ Adding quality test...', 'info');
                log('Adding quality test for product: ' + productId, 'info');
                
                await contract.methods.addQualityTest(
                    productId, testType, results, passed, laboratoryName
                ).send({ from: accounts[0] });
                
                log('Quality test added successfully', 'success');
                showStatus('‚úÖ Quality test added successfully!', 'success');
                document.getElementById('qualityForm').reset();
            } catch (error) {
                log('Error adding quality test: ' + error.message, 'error');
                showStatus('‚ùå Error adding quality test: ' + error.message, 'error');
            }
        });

        // Create Batch
       // Replace your existing batch form event listener in index.html with this updated version:

document.getElementById('batchForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    if (!(await ensureWeb3Connected())) return;

    if (!currentUserRole || !ROLE_ACCESS[currentUserRole].includes('batch')) {
        showStatus('Access denied. You need Processor or Admin role.', 'error');
        return;
    }

    const productIdsInput = document.getElementById('productIds').value;
    const productIds = productIdsInput.split(',').map(id => parseInt(id.trim()));
    const processingFacility = document.getElementById('processingFacility').value;
    const expiryDateInput = document.getElementById('expiryDate').value;
    const expiryDate = Math.floor(new Date(expiryDateInput).getTime() / 1000);
    const packageType = document.getElementById('packageType').value;
    const quantity = document.getElementById('quantity').value;

    try {
        // Validate all product IDs exist first
        showStatus('Validating products...', 'info');
        let validProducts = [];
        
        for (let productId of productIds) {
            if (isNaN(productId) || productId <= 0) {
                throw new Error(`Invalid product ID: ${productId}. Please enter valid numeric IDs.`);
            }
            
            try {
                const product = await contract.methods.getProduct(productId).call();
                validProducts.push({
                    id: productId,
                    name: product.name,
                    status: parseInt(product.status)
                });
                
                // Check if product is eligible for batching (status 0 = Harvested, 1 = Processing)
                if (parseInt(product.status) > 1) {
                    const statusName = STATUS_NAMES[parseInt(product.status)] || 'Unknown';
                    throw new Error(`Product ID ${productId} (${product.name}) has status "${statusName}" and cannot be included in a batch. Only "Harvested" or "Processing" products can be batched.`);
                }
                
            } catch (error) {
                if (error.message.includes('Product does not exist')) {
                    throw new Error(`Product ID ${productId} does not exist. Please verify the product ID.`);
                }
                throw error;
            }
        }

        showStatus(`Creating batch with ${validProducts.length} products...`, 'info');
        log('Creating batch with products: ' + validProducts.map(p => `${p.id} (${p.name})`).join(', '), 'info');
        
        // Disable the submit button
        const submitBtn = e.target.querySelector('button[type="submit"]');
        if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = 'Creating Batch...';
        }
        
        const result = await contract.methods.createBatch(
            productIds, processingFacility, expiryDate, packageType, quantity
        ).send({ 
            from: accounts[0],
            gas: 5000000 // Increased gas limit for multiple status updates
        });
        
        // Get batch ID from the improved event structure
        let batchId = 'Unknown';
        let affectedProducts = [];
        
        if (result && result.events && result.events.BatchCreated) {
            const batchEvent = result.events.BatchCreated;
            if (batchEvent.returnValues) {
                batchId = batchEvent.returnValues.batchId;
                affectedProducts = batchEvent.returnValues.productIds || productIds;
            }
        }
        
        // Check for ProductStatusUpdated events to confirm status changes
        let statusUpdates = 0;
        if (result && result.events && result.events.ProductStatusUpdated) {
            const statusEvents = Array.isArray(result.events.ProductStatusUpdated) 
                ? result.events.ProductStatusUpdated 
                : [result.events.ProductStatusUpdated];
            
            statusUpdates = statusEvents.length;
            log(`${statusUpdates} product statuses updated to "Packaged"`, 'success');
        }
        
        // Success message with details
        const successMessage = `
            Batch created successfully! 
            Batch ID: ${batchId}
            Products updated: ${statusUpdates > 0 ? statusUpdates : productIds.length} 
            Status changed to: "Packaged"
            Processing Facility: ${processingFacility}
        `.replace(/\s+/g, ' ').trim();
        
        log('Batch created successfully with ID: ' + batchId, 'success');
        showStatus(successMessage, 'success');
        
        // Reset form
        document.getElementById('batchForm').reset();
        
        // Re-enable the submit button
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Create Batch';
        }
        
        // Show additional success info
        setTimeout(() => {
            showStatus(`
                Tip: You can now track any of these products (${productIds.join(', ')}) 
                to see their updated "Packaged" status and batch information.
            `.replace(/\s+/g, ' ').trim(), 'info');
        }, 3000);
        
    } catch (error) {
        log('Error creating batch: ' + error.message, 'error');
        showStatus('Error creating batch: ' + error.message, 'error');
        
        // Re-enable the submit button on error
        const submitBtn = e.target.querySelector('button[type="submit"]');
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Create Batch';
        }
    }
    });

        // Register Stakeholder
        document.getElementById('stakeholderForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!(await ensureWeb3Connected())) return;

            const stakeholderAddress = document.getElementById('stakeholderAddress').value || accounts[0];
            const role = document.getElementById('role').value;

            try {
                showStatus('üë§ Registering stakeholder...', 'info');
                log('Registering stakeholder as: ' + role, 'info');
                
                await contract.methods.registerStakeholder(role).send({ 
                    from: accounts[0] 
                });
                
                log('Stakeholder registered successfully', 'success');
                showStatus('‚úÖ Stakeholder registered successfully!', 'success');
                document.getElementById('stakeholderForm').reset();

                if (stakeholderAddress.toLowerCase() === accounts[0].toLowerCase()) {
                    isRoleChecked = false;
                    await updateUIForRole();
                    showStatus(`üéâ Welcome! You are now registered as a ${role}. Your interface has been updated.`, 'success');
                }
            } catch (error) {
                log('Error registering stakeholder: ' + error.message, 'error');
                showStatus('‚ùå Error registering stakeholder: ' + error.message, 'error');
            }
        });

        // Authorize Tester
        async function authorizeTester() {
            const testerAddress = document.getElementById('testerAddress').value;
            
            if (!testerAddress) {
                showStatus('‚ö†Ô∏è Please enter a tester address', 'error');
                return;
            }

            if (!(await ensureWeb3Connected())) return;

            try {
                showStatus('üîç Authorizing tester...', 'info');
                log('Authorizing tester: ' + testerAddress, 'info');
                
                await contract.methods.authorizeTester(testerAddress).send({ from: accounts[0] });
                
                log('Tester authorized successfully', 'success');
                showStatus('‚úÖ Tester authorized successfully!', 'success');
                document.getElementById('testerAddress').value = '';
            } catch (error) {
                log('Error authorizing tester: ' + error.message, 'error');
                showStatus('‚ùå Error authorizing tester: ' + error.message, 'error');
            }
        }

        // Auto-fill current user's address when focusing on stakeholder address input
        document.addEventListener('DOMContentLoaded', () => {
            const stakeholderAddressInput = document.getElementById('stakeholderAddress');
            if (stakeholderAddressInput) {
                stakeholderAddressInput.addEventListener('focus', () => {
                    if (accounts && accounts[0] && !stakeholderAddressInput.value) {
                        stakeholderAddressInput.value = accounts[0];
                    }
                });
            }
        });

        // Allow Enter key to trigger track product
        document.getElementById('trackProductId').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                trackProduct();
            }
        });

        // Initialize the application
        window.addEventListener('load', async () => {
            log('Application loading...', 'info');
            
            // Check if MetaMask is already connected
            if (window.ethereum) {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        log('Existing connection found, initializing...', 'info');
                        await initWeb3();
                    } else {
                        log('No existing connection, showing wallet section', 'info');
                        updateUIForDisconnectedState();
                    }
                } catch (error) {
                    log('Error checking existing connection: ' + error.message, 'warning');
                    updateUIForDisconnectedState();
                }
            } else {
                log('MetaMask not detected', 'warning');
                updateUIForDisconnectedState();
            }
        });

        // Handle MetaMask events
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', async (newAccounts) => {
                log('Account changed event triggered', 'info');
                
                if (newAccounts.length === 0) {
                    log('No accounts after change - user disconnected', 'warning');
                    showStatus('Wallet disconnected', 'warning');
                    resetApplicationState();
                    updateUIForDisconnectedState();
                } else {
                    log('Account changed to: ' + newAccounts[0], 'info');
                    accounts = newAccounts;
                    
                    // Reset role check for new account
                    currentUserRole = null;
                    isRoleChecked = false;
                    
                    // Update UI for new account
                    showStatus('Account changed: ' + accounts[0].substring(0, 8) + '...', 'info');
                    await updateUIForRole();
                }
            });

            window.ethereum.on('chainChanged', () => {
                log('Chain changed - reloading page', 'info');
                window.location.reload();
            });

            window.ethereum.on('disconnect', (error) => {
                log('Wallet disconnected: ' + error.message, 'warning');
                showStatus('Wallet disconnected', 'error');
                resetApplicationState();
                updateUIForDisconnectedState();
            });

            window.ethereum.on('connect', (connectInfo) => {
                log('Wallet connected to chain: ' + connectInfo.chainId, 'success');
                if (!isConnected) {
                    updateConnectionStatus(true);
                    showStatus('Wallet connected successfully', 'success');
                }
            });
        }

        // Add periodic connection health check
        setInterval(async () => {
            try {
                if (web3 && contract && accounts.length > 0 && isConnected) {
                    // Test if we can still make calls
                    const isListening = await web3.eth.net.isListening();
                    if (isListening) {
                        // Connection seems healthy
                        if (document.getElementById('connectionStatus').classList.contains('disconnected')) {
                            log('Connection restored', 'success');
                            updateConnectionStatus(true);
                        }
                    } else {
                        log('Network not listening', 'warning');
                        updateConnectionStatus(false);
                        isConnected = false;
                    }
                } else if (isConnected) {
                    // Something is wrong with our connection but we think we're connected
                    log('Connection appears broken', 'warning');
                    updateConnectionStatus(false);
                    isConnected = false;
                }
            } catch (error) {
                // Connection test failed
                if (isConnected) {
                    log('Connection health check failed: ' + error.message, 'warning');
                    updateConnectionStatus(false);
                    isConnected = false;
                }
            }
        }, 10000); // Check every 10 seconds

        // Export functions for external use or debugging
        window.agriTraceabilityDebug = {
            getWeb3: () => web3,
            getContract: () => contract,
            getAccounts: () => accounts,
            getCurrentRole: () => currentUserRole,
            getLogs: () => debugLog,
            isConnected: () => isConnected,
            forceReconnect: forceReconnect,
            checkStatus: checkCurrentStatus,
            disconnect: disconnectWallet,
            connect: connectWallet,
            switchAccount: switchAccount,
            testContract: async () => {
                if (!contract || !accounts[0]) {
                    console.log("Contract or accounts not available");
                    return false;
                }
                try {
                    const result = await contract.methods.stakeholders(accounts[0]).call();
                    console.log("Contract test successful:", result);
                    return true;
                } catch (error) {
                    console.log("Contract test failed:", error.message);
                    return false;
                }
            }
        };

        log('Agricultural Traceability System with Logout functionality initialized', 'info');
    </script>
</body>
</html> 
