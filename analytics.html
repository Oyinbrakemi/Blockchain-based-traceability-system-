<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analytics Dashboard - Agricultural Traceability System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .nav-btn, .refresh-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .nav-btn:hover, .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .refresh-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .connected {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .disconnected {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            text-align: center;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            color: #666;
            font-size: 1.1em;
            font-weight: 600;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .chart-title {
            color: #2c3e50;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }

        .data-table {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
            overflow-x: auto;
        }

        .data-table h3 {
            color: #2c3e50;
            margin-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .status-badge {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .status-harvested { background: #f39c12; }
        .status-processing { background: #e67e22; }
        .status-packaged { background: #3498db; }
        .status-shipped { background: #9b59b6; }
        .status-delivered { background: #27ae60; }
        .status-recalled { background: #e74c3c; }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.2em;
        }

        .error {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .filters {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filters select, .filters input {
            padding: 8px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            background: white;
        }

        .filters label {
            font-weight: 600;
            color: #2c3e50;
            margin-right: 5px;
        }

        .no-data {
            text-align: center;
            color: #666;
            padding: 40px;
            font-style: italic;
        }

        .insight-card {
            background: linear-gradient(135deg, #e8f5e8, #f0f8f0);
            border: 2px solid #27ae60;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .insight-title {
            color: #27ae60;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }

            .header {
                flex-direction: column;
                text-align: center;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .filters {
                flex-direction: column;
                align-items: stretch;
            }

            .filters > div {
                display: flex;
                align-items: center;
                gap: 10px;
                justify-content: space-between;
            }
        }

        canvas {
            max-height: 400px;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        üî¥ Initializing...
    </div>

    <div class="container">
        <div class="header">
            <h1>üìä Analytics Dashboard</h1>
            <div class="nav-buttons">
                <a href="index.html" class="nav-btn">üè† Main System</a>
                <button onclick="refreshData()" class="refresh-btn">üîÑ Refresh Data</button>
            </div>
        </div>

        <div id="loadingMessage" class="loading">
            üîÑ Loading analytics data from blockchain...
        </div>

        <div id="analyticsContent" style="display: none;">
            <!-- Key Statistics -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="totalProducts">0</div>
                    <div class="stat-label">Total Products</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalBatches">0</div>
                    <div class="stat-label">Total Batches</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalStakeholders">0</div>
                    <div class="stat-label">Registered Stakeholders</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="organicPercentage">0%</div>
                    <div class="stat-label">Organic Products</div>
                </div>
            </div>

            <!-- Filters -->
            <div class="filters">
                <div>
                    <label for="timeFilter">Time Range:</label>
                    <select id="timeFilter" onchange="applyFilters()">
                        <option value="all">All Time</option>
                        <option value="30">Last 30 Days</option>
                        <option value="7">Last 7 Days</option>
                        <option value="1">Today</option>
                    </select>
                </div>
                <div>
                    <label for="statusFilter">Status:</label>
                    <select id="statusFilter" onchange="applyFilters()">
                        <option value="all">All Statuses</option>
                        <option value="0">Harvested</option>
                        <option value="1">Processing</option>
                        <option value="2">Packaged</option>
                        <option value="3">Shipped</option>
                        <option value="4">Delivered</option>
                        <option value="5">Recalled</option>
                    </select>
                </div>
                <div>
                    <label for="organicFilter">Type:</label>
                    <select id="organicFilter" onchange="applyFilters()">
                        <option value="all">All Products</option>
                        <option value="true">Organic Only</option>
                        <option value="false">Non-Organic Only</option>
                    </select>
                </div>
            </div>

            <!-- Charts -->
            <div class="charts-grid">
                <div class="chart-container">
                    <h3 class="chart-title">Product Status Distribution</h3>
                    <canvas id="statusChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="chart-title">Products Registered Over Time</h3>
                    <canvas id="timelineChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="chart-title">Product Origins</h3>
                    <canvas id="originChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="chart-title">Stakeholder Roles</h3>
                    <canvas id="stakeholderChart"></canvas>
                </div>
            </div>

            <!-- Insights -->
            <div id="insights"></div>

            <!-- Recent Activity Table -->
            <div class="data-table">
                <h3>Recent Products</h3>
                <table id="productsTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Variety</th>
                            <th>Origin</th>
                            <th>Status</th>
                            <th>Organic</th>
                            <th>Registered</th>
                        </tr>
                    </thead>
                    <tbody id="productsTableBody">
                    </tbody>
                </table>
            </div>

            <!-- Quality Tests Summary -->
            <div class="data-table">
                <h3>Quality Test Summary</h3>
                <div id="qualityTestSummary" class="no-data">
                    Loading quality test data...
                </div>
            </div>
        </div>

        <div id="errorMessage" style="display: none;"></div>
    </div>

    <script>
        // Contract configuration - match your main application
        const CONTRACT_ADDRESS = "0x74d6683560a8A09bafBC2B1D0a7A47b6fdf4e8cC";
        
        // Fixed Contract ABI with proper structure
        const CONTRACT_ABI = [
            {
                "inputs": [],
                "name": "productCounter",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "batchCounter",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "productId", "type": "uint256"}],
                "name": "getProduct",
                "outputs": [{
                    "components": [
                        {"internalType": "uint256", "name": "id", "type": "uint256"},
                        {"internalType": "string", "name": "name", "type": "string"},
                        {"internalType": "string", "name": "variety", "type": "string"},
                        {"internalType": "string", "name": "origin", "type": "string"},
                        {"internalType": "bool", "name": "isOrganic", "type": "bool"},
                        {"internalType": "string[]", "name": "certifications", "type": "string[]"},
                        {"internalType": "uint8", "name": "status", "type": "uint8"},
                        {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                        {"internalType": "address", "name": "farmer", "type": "address"},
                        {"internalType": "uint256", "name": "plantedDate", "type": "uint256"},
                        {"internalType": "uint256", "name": "harvestDate", "type": "uint256"}
                    ],
                    "internalType": "struct AgricultureTraceability.Product",
                    "name": "",
                    "type": "tuple"
                }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "batchId", "type": "uint256"}],
                "name": "getBatch",
                "outputs": [{
                    "components": [
                        {"internalType": "uint256", "name": "id", "type": "uint256"},
                        {"internalType": "uint256[]", "name": "productIds", "type": "uint256[]"},
                        {"internalType": "string", "name": "processingFacility", "type": "string"},
                        {"internalType": "uint256", "name": "creationDate", "type": "uint256"},
                        {"internalType": "uint256", "name": "expiryDate", "type": "uint256"},
                        {"internalType": "string", "name": "packageType", "type": "string"},
                        {"internalType": "uint256", "name": "quantity", "type": "uint256"},
                        {"internalType": "address", "name": "processor", "type": "address"}
                    ],
                    "internalType": "struct AgricultureTraceability.Batch",
                    "name": "",
                    "type": "tuple"
                }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "productId", "type": "uint256"}],
                "name": "getQualityTests",
                "outputs": [{
                    "components": [
                        {"internalType": "string", "name": "testType", "type": "string"},
                        {"internalType": "string", "name": "results", "type": "string"},
                        {"internalType": "bool", "name": "passed", "type": "bool"},
                        {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                        {"internalType": "address", "name": "tester", "type": "address"},
                        {"internalType": "string", "name": "laboratoryName", "type": "string"}
                    ],
                    "internalType": "struct AgricultureTraceability.QualityTest[]",
                    "name": "",
                    "type": "tuple[]"
                }],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        let web3;
        let contract;
        let allProducts = [];
        let allBatches = [];
        let stakeholderData = [];
        let qualityTestData = [];
        let charts = {};

        const STATUS_NAMES = {
            0: 'Harvested',
            1: 'Processing', 
            2: 'Packaged',
            3: 'Shipped',
            4: 'Delivered',
            5: 'Recalled'
        };

        const STATUS_COLORS = {
            0: '#f39c12',
            1: '#e67e22',
            2: '#3498db',
            3: '#9b59b6',
            4: '#27ae60',
            5: '#e74c3c'
        };

        // Initialize Web3
        async function initWeb3() {
            try {
                updateConnectionStatus('Connecting...');
                
                if (typeof window.ethereum !== 'undefined') {
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                    updateConnectionStatus(true);
                    return true;
                } else {
                    // Fallback with mock data for demonstration
                    updateConnectionStatus('Demo Mode');
                    await loadMockData();
                    return true;
                }
            } catch (error) {
                console.error('Error initializing Web3:', error);
                updateConnectionStatus(false);
                // Load mock data on error for demonstration
                await loadMockData();
                return true;
            }
        }

        // Mock data for demonstration when blockchain is not available
        async function loadMockData() {
            // Generate mock products
            allProducts = [];
            for (let i = 1; i <= 50; i++) {
                allProducts.push({
                    id: i,
                    name: `Product ${i}`,
                    variety: ['Tomato', 'Wheat', 'Rice', 'Corn', 'Potato'][Math.floor(Math.random() * 5)],
                    origin: ['Farm A', 'Farm B', 'Farm C', 'Farm D'][Math.floor(Math.random() * 4)],
                    isOrganic: Math.random() > 0.5,
                    status: Math.floor(Math.random() * 6),
                    timestamp: Date.now() / 1000 - Math.random() * 30 * 24 * 60 * 60, // Random time in last 30 days
                    farmer: '0x' + Math.random().toString(16).substr(2, 40),
                    plantedDate: Date.now() / 1000 - 90 * 24 * 60 * 60,
                    harvestDate: Date.now() / 1000 - 30 * 24 * 60 * 60
                });
            }

            // Generate mock batches
            allBatches = [];
            for (let i = 1; i <= 10; i++) {
                allBatches.push({
                    id: i,
                    productIds: [i * 2, i * 2 + 1],
                    processingFacility: `Facility ${i}`,
                    creationDate: Date.now() / 1000 - Math.random() * 15 * 24 * 60 * 60,
                    expiryDate: Date.now() / 1000 + 30 * 24 * 60 * 60,
                    packageType: ['Box', 'Bag', 'Container'][Math.floor(Math.random() * 3)],
                    quantity: Math.floor(Math.random() * 1000) + 100,
                    processor: '0x' + Math.random().toString(16).substr(2, 40)
                });
            }

            // Generate mock quality test data
            qualityTestData = [];
            for (let i = 1; i <= 30; i++) {
                qualityTestData.push({
                    productId: Math.floor(Math.random() * 50) + 1,
                    productName: `Product ${i}`,
                    testType: ['Pesticide Test', 'Organic Certification', 'Nutritional Analysis', 'Safety Test'][Math.floor(Math.random() * 4)],
                    results: 'Within acceptable limits',
                    passed: Math.random() > 0.1, // 90% pass rate
                    timestamp: Date.now() / 1000 - Math.random() * 15 * 24 * 60 * 60,
                    tester: '0x' + Math.random().toString(16).substr(2, 40),
                    laboratoryName: `Lab ${Math.floor(Math.random() * 5) + 1}`
                });
            }

            updateStatistics();
            renderCharts();
            updateDataTables();
            generateInsights();

            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('analyticsContent').style.display = 'block';
            showSuccess('Demo data loaded successfully!');
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            if (status === true) {
                statusElement.textContent = 'üü¢ Connected';
                statusElement.className = 'connection-status connected';
            } else if (status === false) {
                statusElement.textContent = 'üî¥ Disconnected';
                statusElement.className = 'connection-status disconnected';
            } else {
                statusElement.textContent = 'üü° ' + status;
                statusElement.className = 'connection-status';
                statusElement.style.background = 'linear-gradient(45deg, #f39c12, #e67e22)';
                statusElement.style.color = 'white';
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div class="error">${message}</div>`;
            errorDiv.style.display = 'block';
            document.getElementById('loadingMessage').style.display = 'none';
        }

        function showSuccess(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div class="success">${message}</div>`;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Load all data from blockchain
        async function loadAnalyticsData() {
            try {
                document.getElementById('loadingMessage').style.display = 'block';
                document.getElementById('analyticsContent').style.display = 'none';
                document.getElementById('errorMessage').style.display = 'none';

                if (!contract) {
                    await loadMockData();
                    return;
                }

                // Get total counts
                const productCount = await contract.methods.productCounter().call();
                const batchCount = await contract.methods.batchCounter().call();

                console.log(`Found ${productCount} products and ${batchCount} batches`);

                // Load all products
                allProducts = [];
                for (let i = 1; i <= productCount; i++) {
                    try {
                        const product = await contract.methods.getProduct(i).call();
                        allProducts.push({
                            ...product,
                            id: parseInt(product.id),
                            status: parseInt(product.status),
                            timestamp: parseInt(product.timestamp),
                            plantedDate: parseInt(product.plantedDate),
                            harvestDate: parseInt(product.harvestDate)
                        });
                    } catch (error) {
                        console.warn(`Failed to load product ${i}:`, error.message);
                    }
                }

                // Load all batches
                allBatches = [];
                for (let i = 1; i <= batchCount; i++) {
                    try {
                        const batch = await contract.methods.getBatch(i).call();
                        allBatches.push({
                            ...batch,
                            id: parseInt(batch.id),
                            creationDate: parseInt(batch.creationDate),
                            expiryDate: parseInt(batch.expiryDate),
                            quantity: parseInt(batch.quantity)
                        });
                    } catch (error) {
                        console.warn(`Failed to load batch ${i}:`, error.message);
                    }
                }

                // Load quality test data
                await loadQualityTestData();

                // Update UI with loaded data
                updateStatistics();
                renderCharts();
                updateDataTables();
                generateInsights();

                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('analyticsContent').style.display = 'block';
                showSuccess('Analytics data loaded successfully!');

            } catch (error) {
                console.error('Error loading analytics data:', error);
                showError('Failed to load analytics data: ' + error.message);
                // Fallback to mock data
                await loadMockData();
            }
        }

        async function loadQualityTestData() {
            qualityTestData = [];
            
            for (let product of allProducts) {
                try {
                    const tests = await contract.methods.getQualityTests(product.id).call();
                    for (let test of tests) {
                        qualityTestData.push({
                            productId: product.id,
                            productName: product.name,
                            testType: test.testType,
                            results: test.results,
                            passed: test.passed,
                            timestamp: parseInt(test.timestamp),
                            tester: test.tester,
                            laboratoryName: test.laboratoryName
                        });
                    }
                } catch (error) {
                    console.warn(`Failed to load quality tests for product ${product.id}`);
                }
            }
        }

        function updateStatistics() {
            document.getElementById('totalProducts').textContent = allProducts.length;
            document.getElementById('totalBatches').textContent = allBatches.length;
            
            const organicCount = allProducts.filter(p => p.isOrganic).length;
            const organicPercentage = allProducts.length > 0 ? Math.round((organicCount / allProducts.length) * 100) : 0;
            document.getElementById('organicPercentage').textContent = organicPercentage + '%';
            
            const uniqueFarmers = new Set(allProducts.map(p => p.farmer)).size;
            document.getElementById('totalStakeholders').textContent = uniqueFarmers;
        }

        function renderCharts() {
            Object.values(charts).forEach(chart => {
                if (chart) chart.destroy();
            });

            renderStatusChart();
            renderTimelineChart();
            renderOriginChart();
            renderStakeholderChart();
        }

        function renderStatusChart() {
            const statusCounts = {};
            Object.keys(STATUS_NAMES).forEach(status => {
                statusCounts[status] = allProducts.filter(p => p.status == status).length;
            });

            const ctx = document.getElementById('statusChart').getContext('2d');
            charts.statusChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.values(STATUS_NAMES),
                    datasets: [{
                        data: Object.values(statusCounts),
                        backgroundColor: Object.values(STATUS_COLORS),
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        function renderTimelineChart() {
            const dateGroups = {};
            allProducts.forEach(product => {
                const date = new Date(product.timestamp * 1000).toISOString().split('T')[0];
                dateGroups[date] = (dateGroups[date] || 0) + 1;
            });

            const sortedDates = Object.keys(dateGroups).sort();
            const ctx = document.getElementById('timelineChart').getContext('2d');
            
            charts.timelineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sortedDates,
                    datasets: [{
                        label: 'Products Registered',
                        data: sortedDates.map(date => dateGroups[date]),
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Number of Products'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function renderOriginChart() {
            const originCounts = {};
            allProducts.forEach(product => {
                const origin = product.origin || 'Unknown';
                originCounts[origin] = (originCounts[origin] || 0) + 1;
            });

            const ctx = document.getElementById('originChart').getContext('2d');
            charts.originChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(originCounts),
                    datasets: [{
                        label: 'Products by Origin',
                        data: Object.values(originCounts),
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: '#667eea',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function renderStakeholderChart() {
            const roles = ['Farmers', 'Processors', 'Distributors', 'Quality Inspectors'];
            const counts = [
                new Set(allProducts.map(p => p.farmer)).size,
                allBatches.length > 0 ? new Set(allBatches.map(b => b.processor)).size : 1,
                Math.ceil(allProducts.length * 0.3),
                Math.ceil(qualityTestData.length * 0.1) || 1
            ];

            const ctx = document.getElementById('stakeholderChart').getContext('2d');
            charts.stakeholderChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: roles,
                    datasets: [{
                        data: counts,
                        backgroundColor: ['#f39c12', '#e67e22', '#3498db', '#27ae60'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        function updateDataTables() {
            const tbody = document.getElementById('productsTableBody');
            tbody.innerHTML = '';
            
            const recentProducts = allProducts
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 10);

            recentProducts.forEach(product => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${product.id}</td>
                    <td>${product.name}</td>
                    <td>${product.variety}</td>
                    <td>${product.origin}</td>
                    <td><span class="status-badge status-${STATUS_NAMES[product.status].toLowerCase()}">${STATUS_NAMES[product.status]}</span></td>
                    <td>${product.isOrganic ? '‚úÖ Yes' : '‚ùå No'}</td>
                    <td>${new Date(product.timestamp * 1000).toLocaleDateString()}</td>
                `;
            });

            updateQualityTestSummary();
        }

        function updateQualityTestSummary() {
            const summaryDiv = document.getElementById('qualityTestSummary');
            
            if (qualityTestData.length === 0) {
                summaryDiv.innerHTML = '<div class="no-data">No quality test data available</div>';
                return;
            }

            const totalTests = qualityTestData.length;
            const passedTests = qualityTestData.filter(test => test.passed).length;
            const passRate = Math.round((passedTests / totalTests) * 100);
            
            const testTypes = {};
            qualityTestData.forEach(test => {
                if (!testTypes[test.testType]) {
                    testTypes[test.testType] = { total: 0, passed: 0 };
                }
                testTypes[test.testType].total++;
                if (test.passed) testTypes[test.testType].passed++;
            });

            let summaryHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="stat-card">
                        <div class="stat-number">${totalTests}</div>
                        <div class="stat-label">Total Tests</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${passedTests}</div>
                        <div class="stat-label">Tests Passed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${passRate}%</div>
                        <div class="stat-label">Pass Rate</div>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Test Type</th>
                            <th>Total Tests</th>
                            <th>Passed</th>
                            <th>Pass Rate</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            Object.entries(testTypes).forEach(([testType, stats]) => {
                const rate = Math.round((stats.passed / stats.total) * 100);
                summaryHTML += `
                    <tr>
                        <td>${testType}</td>
                        <td>${stats.total}</td>
                        <td>${stats.passed}</td>
                        <td>
                            <span class="status-badge ${rate >= 90 ? 'status-delivered' : rate >= 70 ? 'status-shipped' : 'status-recalled'}">
                                ${rate}%
                            </span>
                        </td>
                    </tr>
                `;
            });

            summaryHTML += '</tbody></table>';
            summaryDiv.innerHTML = summaryHTML;
        }

        function generateInsights() {
            const insightsDiv = document.getElementById('insights');
            const insights = [];

            const organicCount = allProducts.filter(p => p.isOrganic).length;
            const organicPercentage = allProducts.length > 0 ? Math.round((organicCount / allProducts.length) * 100) : 0;
            
            if (organicPercentage > 50) {
                insights.push({
                    title: 'üå± Strong Organic Focus',
                    message: `${organicPercentage}% of your products are organic, showing strong commitment to sustainable farming practices.`
                });
            } else if (organicPercentage > 25) {
                insights.push({
                    title: 'üåø Growing Organic Presence',
                    message: `${organicPercentage}% of products are organic. Consider promoting organic farming to increase this percentage.`
                });
            }

            const deliveredCount = allProducts.filter(p => p.status == 4).length;
            const deliveryRate = allProducts.length > 0 ? Math.round((deliveredCount / allProducts.length) * 100) : 0;
            
            if (deliveryRate > 80) {
                insights.push({
                    title: 'üì¶ Excellent Delivery Performance',
                    message: `${deliveryRate}% of products have been successfully delivered, indicating strong supply chain efficiency.`
                });
            } else if (deliveryRate < 50) {
                insights.push({
                    title: '‚ö†Ô∏è Delivery Optimization Needed',
                    message: `Only ${deliveryRate}% of products have been delivered. Consider reviewing supply chain processes.`
                });
            }

            if (qualityTestData.length > 0) {
                const passedTests = qualityTestData.filter(test => test.passed).length;
                const passRate = Math.round((passedTests / qualityTestData.length) * 100);
                
                if (passRate >= 95) {
                    insights.push({
                        title: 'üèÜ Outstanding Quality Standards',
                        message: `${passRate}% quality test pass rate demonstrates exceptional product quality control.`
                    });
                } else if (passRate < 85) {
                    insights.push({
                        title: 'üîç Quality Improvement Opportunity',
                        message: `${passRate}% quality test pass rate. Consider reviewing quality control processes.`
                    });
                }
            }

            if (allProducts.length > 100) {
                insights.push({
                    title: 'üìà High Production Volume',
                    message: `With ${allProducts.length} products tracked, you're managing substantial agricultural production.`
                });
            }

            const recentProducts = allProducts.filter(p => {
                const daysSince = (Date.now() - p.timestamp * 1000) / (1000 * 60 * 60 * 24);
                return daysSince <= 7;
            });
            
            if (recentProducts.length > 0) {
                insights.push({
                    title: 'üïí Recent Activity',
                    message: `${recentProducts.length} products have been registered in the last 7 days, showing active system usage.`
                });
            }

            let insightsHTML = '';
            insights.forEach(insight => {
                insightsHTML += `
                    <div class="insight-card">
                        <div class="insight-title">${insight.title}</div>
                        <div>${insight.message}</div>
                    </div>
                `;
            });

            if (insights.length === 0) {
                insightsHTML = '<div class="no-data">Loading insights...</div>';
            }

            insightsDiv.innerHTML = insightsHTML;
        }

        function applyFilters() {
            const timeFilter = document.getElementById('timeFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            const organicFilter = document.getElementById('organicFilter').value;

            let filteredProducts = allProducts;

            if (timeFilter !== 'all') {
                const days = parseInt(timeFilter);
                const cutoffTime = Date.now() - (days * 24 * 60 * 60 * 1000);
                filteredProducts = filteredProducts.filter(p => p.timestamp * 1000 >= cutoffTime);
            }

            if (statusFilter !== 'all') {
                const status = parseInt(statusFilter);
                filteredProducts = filteredProducts.filter(p => p.status === status);
            }

            if (organicFilter !== 'all') {
                const isOrganic = organicFilter === 'true';
                filteredProducts = filteredProducts.filter(p => p.isOrganic === isOrganic);
            }

            updateFilteredDisplays(filteredProducts);
        }

        function updateFilteredDisplays(filteredProducts) {
            document.getElementById('totalProducts').textContent = filteredProducts.length;
            
            const organicCount = filteredProducts.filter(p => p.isOrganic).length;
            const organicPercentage = filteredProducts.length > 0 ? Math.round((organicCount / filteredProducts.length) * 100) : 0;
            document.getElementById('organicPercentage').textContent = organicPercentage + '%';

            const tbody = document.getElementById('productsTableBody');
            tbody.innerHTML = '';
            
            const displayProducts = filteredProducts
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 20);

            displayProducts.forEach(product => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${product.id}</td>
                    <td>${product.name}</td>
                    <td>${product.variety}</td>
                    <td>${product.origin}</td>
                    <td><span class="status-badge status-${STATUS_NAMES[product.status].toLowerCase()}">${STATUS_NAMES[product.status]}</span></td>
                    <td>${product.isOrganic ? '‚úÖ Yes' : '‚ùå No'}</td>
                    <td>${new Date(product.timestamp * 1000).toLocaleDateString()}</td>
                `;
            });

            updateChartsWithFilteredData(filteredProducts);
        }

        function updateChartsWithFilteredData(filteredProducts) {
            const statusCounts = {};
            Object.keys(STATUS_NAMES).forEach(status => {
                statusCounts[status] = filteredProducts.filter(p => p.status == status).length;
            });

            if (charts.statusChart) {
                charts.statusChart.data.datasets[0].data = Object.values(statusCounts);
                charts.statusChart.update();
            }

            const originCounts = {};
            filteredProducts.forEach(product => {
                const origin = product.origin || 'Unknown';
                originCounts[origin] = (originCounts[origin] || 0) + 1;
            });

            if (charts.originChart) {
                charts.originChart.data.labels = Object.keys(originCounts);
                charts.originChart.data.datasets[0].data = Object.values(originCounts);
                charts.originChart.update();
            }
        }

        async function refreshData() {
            const refreshBtn = document.querySelector('.refresh-btn');
            const originalText = refreshBtn.textContent;
            
            refreshBtn.textContent = 'üîÑ Refreshing...';
            refreshBtn.disabled = true;
            
            try {
                await loadAnalyticsData();
                showSuccess('Data refreshed successfully!');
            } catch (error) {
                showError('Failed to refresh data: ' + error.message);
            } finally {
                refreshBtn.textContent = originalText;
                refreshBtn.disabled = false;
            }
        }

        async function initApp() {
            const connected = await initWeb3();
            if (connected) {
                await loadAnalyticsData();
            }
        }

        window.addEventListener('load', initApp);
        
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('accountsChanged', function (accounts) {
                console.log('Account changed:', accounts[0]);
                initApp();
            });
            
            window.ethereum.on('chainChanged', function (chainId) {
                console.log('Chain changed:', chainId);
                initApp();
            });
        }

        function exportToCSV() {
            const headers = ['ID', 'Name', 'Variety', 'Origin', 'Status', 'Organic', 'Registered Date'];
            const csvContent = [headers.join(',')];
            
            allProducts.forEach(product => {
                const row = [
                    product.id,
                    `"${product.name}"`,
                    `"${product.variety}"`,
                    `"${product.origin}"`,
                    STATUS_NAMES[product.status],
                    product.isOrganic ? 'Yes' : 'No',
                    new Date(product.timestamp * 1000).toLocaleDateString()
                ];
                csvContent.push(row.join(','));
            });
            
            const blob = new Blob([csvContent.join('\n')], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'agricultural_analytics_' + new Date().toISOString().split('T')[0] + '.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>